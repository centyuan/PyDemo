# 1、查看CPU个数：
lscpu
# 2、查看CPU进程数、核数：
cat /proc/cpuinfo
# 3、查看内存总量：
free -m
# 4、查看磁盘挂载情况:
lsblk
# 5、查看磁盘分区情况：
fdisk -l
# 6、查看磁盘:
df -h  # disk free以磁盤分区为单位查看文件系统
du -ah # 显示文件或目录的大小
cat test |sort|uniq -u  # -u仅显示不重复的,-d仅显示重复的
### 找出系统最大的前十个文件 https://linux.cn/article-9495-1.html
# find 的输出是文件名加一个换行符du 接受这个输入时会出现问题，我们需要用 -print0 选项把 find 输出的换行符改成 \0，
# 这个大家很熟悉吧，字符串的结束标志，再配合用 xargs 将其分割成小块传给 du 命令
find / -type f -print0 | xargs -O du -h |sort -rh|head -n 10
find / -type f -exec du -Sh {} + | sort -rh | head -n 10


# 7.查看Linux内核版本命令
 cat /proc/version
 uname -a
# 8. 查看Linux发现版
 lsb_release -a
 cat /etc/redhat-release  # 只适合Redhat系的Linux
 cat /etc/issue

# 9.查看物理CPU个数和型号
# cut:-d:(表示以:分割)，-f2(-f配合-d去第2部分);# uniq -c(去重,-c显示有多少重复的)
cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c

# 10.查看单个物理CPU核心数
# wc(-l显示列数-c显示Bytes数-w显示字数) 计算文件的Byte数，字数和列数
# wc testfile
# 3    92    598 testfile
# 行数 单词数 字节数
cat /proc/cpuinfo | grep "physical id" | sort |wc-l

统计项目	统计方式	业务含义
物理CPU的数量	cat /proc/cpuinfo | grep "physical id" | uniq | wc -l	物理机器插槽中CPU的数量4
逻辑处理器数量	cat /proc/cpuinfo | grep "processor" | sort -u | wc -l	processor 0 ~ n - 1 ，其中 n 为逻辑处理器数量
处理器内核数量	cat /proc/cpuinfo | grep "core id" | uniq | wc -l	所有物理CPU上的core的个数总和
处理器内核数量	cat /proc/cpuinfo | grep "cpu cores" | sort | uniq	每个物理CPU中Core的个数
逻辑处理器数量	cat /proc/cpuinfo | grep "siblings" | sort | uniq	每个物理CPU 内包含的逻辑处理器的数量

# 11.内存占用前10
ps aux | head -1;ps auxw | sort -rnk 4 | head -10

# 12.cpu占用前10
ps aux | head -1;ps aux | sort -rnk 3 | head -10

# 13.查看某进程的cpu和内存使用情况
top -p 1081 -H

# 14.显示目录或文件的大小
du -h /home/centyuan
df -h：命令查看了一下磁盘使用情况
df -i：查看了一下/data分区的索引节点(inode)，发现已经用满(IUsed=100%)，导致系统无法创建新目录和文件

# 15.sudo
su切换用户后:在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令
sudo:暂时切换到超级用户模式以执行超级用户权限，提示输入密码时该密码为当前用户的密码，而不是超级账户的密码。不过有时间限制，Ubuntu默认为一次时长15分钟。
sudo -i: 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时该密码为当前账户的密码。没有时间限制。执行该命令后提示符变为“#”而不是“$”。想退回普通账户时可以执行“exit”或“logout” 。
su:切换到某某用户模式，提示输入密码时该密码为切换后账户的密码，用法为“su 账户名称”。如果后面不加账户时系统默认为root账户，密码也为超级账户的密码。没有时间限制。

# 16.查看文件命令
cat tac nl more less head tail

# 17.搜索文件命令(whereis which find locate)
find       实际搜寻硬盘查询文件名称(最强大的,可以通过文件的时间戳,文件的权限)
locate     配合数据库查看文件位置(快而全,通过/var/lib/mlocate/mlocate.db数据库查找,每天自动更新一次)
# 查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：
locate /etc/sh
which      通常用来确定是否安装指定的软件,因为只从PATH环境变量制定的路径中取搜索命令
whereis    查看可执行文件的位置(搜索很快,从数据库中差,不从硬盘中查,只能搜索二进制文件-b man帮助文件-m,和源代码文件 -s)

# 15.&
&  表示任务在后台执行，如要在后台运行redis-server:redis-server &
&& 表示前一条命令执行成功时，才执行后一条命令:echo '1‘ && echo '2'
|| 表示上一条命令执行失败后，才执行下一条命令，如  cat nofile || echo "fail"
| 表示管道，上一条命令的输出，作为下一条命令参数:echo 'yes' | wc -l
&和nohup 区别:
&:1.结果输出到终端，2.Ctrl+c发送SIGINT信号，程序免疫,3.关闭session发送SIGKILL信号,程序关闭
nohup:1.结果默认输出到nohup.out,2.Ctrl+c发送SIGINT信号,程序关闭,3.关闭session发送SIGHUP信号，程序免疫
不挂断后台运行(nohup $ 同时使用)
nohup python run.py >aceess.log 2>&1  &
nohup python3 -u manage.py runserver 0.0.0.0:8001 > out.log 2>&1 &
# 2>&1 解释：
将标准错误 2 重定向到标准输出 &1 ，在将标准输出 &1 再被重定向输入到 out.log
# 2>1 解释:
表示把标准错误的输出重定向到1，但这个1不是标准输出，而是一个名为1的文件。
# &> 解释:
表示stdout标准输出和stderr错误输出信息，重定向输出，覆盖写。
nohup python manage.py runserver 0.0.0.0:8001 &
rz:上传文件
sz:下载文件

# 16.服务自启三种方式
1.systemd
cd /etc/systemd/system/
vim test.service
***********
[Unit]
Description = test
After=network.target
[Service]
ExecStart=/home/tomcat/jenkins_8093/bin/startup.sh
ExecStop=/home/tomcat/jenkins_8093/bin/shutdown.sh
ExecReload=/bin/kill -s HUP $MAINPID
[Install]
WantedBy=multi-user.target
***********
systemctl enable|disable test.service
(urs/lib/systemd/system/test.service)

2./etc/rc.d/rc.local
vim /etc/rc.d/rc.local
自启命令

3.crontab计划中的@reboot
crontab -e
@reboot /home/test.sh


#17.linux启动过程
1.开机质检(硬件引导):BIOS/UEFI(硬件初始化)
2.内核引导:boot(加载内核)
3.运行init/SystemV/Systemd(pid为1):(7个运行级别)挂载文件系统等
4.系统初始化:rc.d


docker run --name my_es7 -p 9200:9200  -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms84m -Xmx512m" -v /root/my_elasticsearch/data:/usr/share/elasticsearch/data -d elasticsearch:7