

**面试题**

>Go面试宝典(八股文): https://golang.design/go-questions/compile/escape/
>
>Go面试复习指南(八股文): https://xmcy0011.github.io/interview-golang/
>
>Go高性能编程: https://geektutu.com/post/high-performance-go.html
>
>golang roadmap(语法): https://www.golangroadmap.com/docs/introduce/1.html
>
>go语言中文文档(语法): https://www.topgoer.com/
>
>面试题(题): http://mian.topgoer.com/
>
>go语言设计与实现(源码解读): https://draveness.me/golang/docs/



##### Golang的内存模型

>栈stack: 用于存储函数调用时的局部变量和函数参数，分配回收快
>堆heap: 存储跨函数的数据，有GC管理
>
>值类型： int、float、bool、string、数组、struct
>>变量存储了实际的数据，值类型变量赋值时，会进行值拷贝，变量相互独立不影响
>>值类型通常在栈上分配，除非是通过 new 函数分配的，或者是作为闭包中的变量被分配到堆上
>
>引用类型: 指针、切片slice、管道channel、接口interface、map、函数
>>引用类型存储指向数据的指针
>>引用类型的数据通常在堆上分配，即使变量本身在栈上
>
>**Go语言中函数传参都是值传递**
>定义变量都是通过声明或make/new函数，make/new都是显示声明并初始化，声明的变量没初始化，则该变量的默认值就是对应类型的零值



##### Slice原理

>slice底层实现是数组，通过数组指针、长度(len)、容量(cap)三个字段，实现了类似动态数组的功能，封装了快速访问底层数组的能力，使用索引下标，切片会自动计算底层数组的地址偏移
>
>`底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的`
>
>```
>//runtime/slice.go
>type slice struct {
>	array unsafe.Pointer  //元素指针
>	len   int   //长度
>	cap   int   //容量
>}
>```
>
>**数组和切片的区别**
>
>>1.数组静态长度编译期确定,切片动态的
>>
>>2.可以基于数组创建切片，反之不行
>>
>>3.数组是值类型在栈上分配，切片是引用类型，在堆上分配且必须使用make初始化(字面量是语法糖，也是使用mak初始化)
>
>**切片怎么扩容的？**
>append时如果容量不足会触发扩容，go编译器会调用growslice()
>
>```
>新容量计算:
>	- 如果期望容量大小超过现有容量2倍，则直接使用期望容量
>	- 如果原slice容量小于1024(Go1.18后是256),新的slice容量变为原来的2倍，大于1024则新的slice容量变为原来的1.25倍
>最终容量计算:
>	为避免内存碎片，会进行`内存对齐计算`，最后结果会大于等于上面的
>	roundupsize 函数用来计算内存对齐后最终的容量值，实际上就是根据所需内存大小进行向上取整，然后使用数组 class_to_size 中的整数以提供内存分配效率并减少内存碎片
>```
>
>**切片使用注意**
>
>>1.设置合理的初始化大小，避免不必要的扩容
>>2.for遍历切片时，value是元素的拷贝，当元素是值类型时，对其更改不会影响切片中元素
>>3.避免切片污染(reslice)



##### Map原理

>Map的2中实现:
>
>- 哈希表(hash tables): 关键在于哈希函数的选择和哈希冲突时的解决办法（Go中使用拉链法解决），最坏情况是O(n)、平均O(1)
>- 搜索树(search trees): 使用自平衡二叉查找树来查找value（C++中的map就是基于红黑树实现，面试时经常会被问到），最坏O(log n)，平均O(log n)
>
>Go中Map使用Hash Tables实现
>常用解决hash冲突的方法是`开发寻址法`和`拉链法`
>**开放寻址法:** 依次探测和比较数组中的元素以判断目标键值对是否存在哈希表中，如果存在则把元素插入到冲突key的下一个位置
>**拉链法:** 
>
>**Map怎么扩容的？**
>
>`装载因子=元素个数/桶bucket数量`
>
>在向map插入新key时，会触发扩容检查:
>
>1. 装载因子超过阈值(6.5)
>2. 哈希使用了太多溢出桶, overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B >= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。



##### 如何比较两个map相等

>- 都为nil
>- 非空、长度相等、指向同一个map实体对象
>- 相应的key指向的value“深度"相等

##### channel死锁场景

>1.没有缓冲区的时候,单协程内通道写早于读
>
>2.没有数据的时候进行读,(可以使用select来规避)
>
>3.chan1和chan2循环依赖
>
>4.有缓冲区,收发在同一协程,但是缓冲区已满
>
>5.有缓冲区,缓冲区没数据，继续从channel取数据

##### 读写channel哪个先关

>负责写chan的goroutine先关闭
>
>因为关闭chan后,写会panic，读不会(返回通道类型的零值)



##### goroutine 

>GPM是go runtime层面的实现，是go自己实现的一套调度系统
>
>1. G 代表goroutine
>2. M表示内核线程
>3. P代表一个虚拟的Processer，维护处于一个Runnable状态的g队列，m需要获得p才能运行g



##### GC垃圾回收

>**根对象**： 垃圾回收器在标记过程中最先检查的对象，包括：
>
>1. 全局变量: 编译期就确定哪些存在于整个生命周期的变量
>2. 执行栈: 每个goroutine都有自己的执行栈，包含栈上的变量及指向分配的堆内存区块的指针
>3. 寄存器: 
>
>
>
>**常见的GC实现方式有哪些?**
>`所有的GC算法可以归结为追踪Tracing和引用计数Reference Counting两种形式`
>
>- 追踪式：从根对象出发，扫描所有对象，根据对象之间的引用信息来确定保留还是回收
>- 引用计数: 每个对象自身包含一个被引用的计数器
>
>
>
>**三色标记法**
>还是属于追踪式的标记清除的方式，将对象分为不同颜色:
>
>- 白色对象(可能死亡)：未被回收器访问到的对象，在回收开始阶段，所有对象均为白色，回收结束后，白色对象不可达
>- 灰色对象(波面)：已被回收器访问的对象，但还需要对其中的一个或多个指针进行扫描，因为他们可能指向白色对象
>- 黑色对象(确定存货)：已被回收器访问，所有字段都被扫描，没有指向白色对象的指针
>
>这样三种不变性所定义的回收过程其实是一个**波面**不断前进的过程，这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。
>
>**STW**
>Stop the World: STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程
>
>



##### 面试题

###### 内存逃逸分析

>在编译原理中，分析指针动态范围的方法称之为逃逸分析，Go中的逃逸分析是编译器执行静态代码分析后，对内存管理进行的优化，可以决定一个变量是分配到堆上还是栈上
>
>变量内存从栈上逃逸到堆上，有些变量在函数运行结束后仍要使用，需要把这个变量在堆上分配
>
>栈上分配的地址一般有系统申请和释放，不会有额外的开销，堆上的需要GC来回收，变量一旦逃逸会导致性能开销变大
>
>**变量生命周期尽量短**,

`Go语言逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。`

> `go build -gcflags '-m'`命令可以观察变量是否逃逸

`常见的逃逸情况总结`

>1. 指针逃逸：函数内部返回一个局部变量指针
>2. 分配大对象：导致栈空间不足，不得不分配到堆上
>3. 调用接口类型的方法，接口类型的方法调用是动态调度 - 实际使用的具体实现只能在运行时确定。
>4. 尽管能够符合分配到栈的场景，但是其大小不能在编译的时候确定，也会分配到堆上。

>- 栈上分配内存比在堆中分配内存效率更高
>- 栈上分配的内存不需要GC处理，而堆上需要
>- 逃逸分析的目的是决定内存分配地址是栈还是堆
>- 逃逸分析在编译阶段完成
>



**MoE vs 集成学习**

MoE:
>技术: 神经网络
>目的: 提高模型收敛和推理速度
>训练步骤： 1.将任务分成若干个子任务，每个子任务训练一个专家模型，2.开发一个门控模型，来预测输入应分配给那个专家模型
>结果输出：组合各个模型的输出结果

集成学习:
>技术: 机器学习
>目的：提供模型预测精确度
>训练步骤：训练不同的学习器或者多个相同的学习器，比如决策树，SVM,朴素贝叶斯，逻辑回归等，这些基础学习器可以使用相同或不同的训练数据，按照学习策略和训练串行或者并行方式，可分为:
>Bagging(独立),Boosting(依赖)，Stacking等

