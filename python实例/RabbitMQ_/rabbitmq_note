###rabbitmq的工作模式:
1.simple模式一对一:producer -> queue -> consumer
2.worker工作模式一对多:producer ->queue ->consumer1,consumer2,consumer3
高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用
3.发布订阅模式(publish/subscribe)
4.routing路由模式:
5.topic主题模式:#(代表0,1,多个),*(至少有一个)
###exchange有多个种类：
常用的有direct,fanout,topic,headers
(fanout)1:N,Exchange不需要处理Route key,把消息路由到与该Exchange绑定Binding的所有Queue
(topic)N:1,多个exchange路由到同一个queue,根据routing key的模糊匹配
(headers):不依赖routing key和binding key的匹配规则来路由消息,根据发送的消息内容中的headers属性(及参数)进行匹配
(direct)1:1,把消息路由到那些binding key与routing key完全匹配的Queue中
direct Exchange是RabbitMQ Broker的默认Exchange它有一个特别的属性对一些简单的应用来说是非常有用的，
在使用这个类型的Exchange时,可以不必指定routing key的名字,在此类型下创建的Queue有一个默认的routing key,这个routing key一般同Queue同名。
###woker模式:消息的轮询分发和公平分发(使用默认的direct的exchange)
轮询分发(默认):!!!autoAck必须采用自动应答,
公平分发(能者多劳):必须采用手动应答(手动ack)和定义指标qos(一次取多少条消息)=1


###死信队列:
1.消息过期
2.消息被拒绝
3.队列达到最大长度

rabbitmq内存磁盘监控
# 内存使用超过配置的阈值,或磁盘剩余空间低于配置的阈值会警告,rabbitmq连接会被挂起
rabbitmqctl set_vm_memory_high_watermark.relative=0.4-0.6
rabbitmqctl set_vm_memory_high_watermark.absolute=2GB
rabbitmqctl set_disk_free_limit 100GB
# 内存换页,内存使用率达到一定值,将内存中数据转入磁盘中
vm_memory_high_watermark_paging_ratio=0.7

###rabbitmq集群搭建
1.停止rabbitmq服务
2.启动第一个节点
sudo RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1 rabbit-server start &
3.启动第二个节点
sudo RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15673}]" RABBITMQ_NODENAME=rabbit-2 rabbitmq-server start &
4.修改rabbit-1为主节点
 sudo rabbitmqctl -n rabbit-1 stop_app  # 1.停止应用
 sudo rabbitmqctl -n rabbit-1 reset     # 2.重置,清除节点上的历史数据(否则无法加入节点)
 sudo rabbitmqctl -n rabbit-1 start_app # 3.启动应用
5.修改rabbit-2为从节点
 sudo rabbitmqctl -n rabbit-2 stop_app
 sudo rabbitmqctl -n rabbit-2 reset
 sudo rabbitmqctl -n rabbit-2 join_cluster rabbit-1@主机名
 sudo rabbitmqctl -n rabbit-2 start_app
6.验证集群状态
sudo rabbitmqctl cluster_status -n rabbit-1

### rabbitmq消息确认机制
1.生产者发送消息确认分为:Confirm消息确认(将信道设置成Confirm模式,成功失败都有返回)和Return(投递失败时才有返回)消息机制
2.消费者采用ack模式

### exclusive
exclusive:指示队列是否是排他性。如果一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除。
1. 排他队列是基于连接可见的，同一连接的不同信道Channel是可以同时访问同一连接创建的排他队列；
2.“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；
3.即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。
autoDelete:是否自动删除。如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于发布订阅方式创建的临时队列

### 持久化
exchange和queue:通过durable参数设置
消息:通过properties = pika.BasicProperties(delivery_mode=2)设置
设置了队列和消息持久化后，当服务重启之后，消息仍然存在。只设置队列持久化，不设置消息持久化，重启之后消息会丢失；只设置消息持久化，
不设置队列持久化，在服务重启后，队列会消失，从而依附于队列的消息也会丢失。只设置消息持久化而不设置队列的持久化，毫无意义。

### mandatory
当消息无法找到对应的queue时
mandatory ：true 返回消息给生产者
mandatory: false 直接丢弃