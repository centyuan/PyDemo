"""
# 一:变量/类属性
1.类属性只有一个:
所有的实例都可以访问类属性，且访问的类属性是同一个，一旦类属性改变就会影响到所有的实例。
2.变量:
在Python中，有以下几种方式来定义变量：
xx：公有变量
_xx：单前置下划线，被看作是“protect”化属性或方法(1.约定仅供内部使用,不强制,2.(模块内部使用)from somemodule import *禁止导入)
__xx：双前置下划线，被看作是"private”化属性或方法(无法在外部直接访问只能内部访问（名字重整所以访问不到,实例对象._类名__变量名可强制访问）)
__xx__：双前后下划线，系统定义名字（不要自己发明这样的名字）
xx_：单后置下划线，用于避免与Python关键词的冲突

# 二:函数/方法
1.方法作用域
object  #公用方法

_object #半保护
     被看作是“protect”,约定只能类对象和子类对象自己能访问到这些变量(不强制)
     不能用’from module import *’导入(通配符导入),则模块外不能使用(可以指定导入)

__object  #全私有，全保护
        #私有成员“private”，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据，不能用’from module import *’导入。
        #__object 是为了避免与子类的方法名称冲突， 对于该标识符描述的方法，父类的方法不能轻易地被子类的方法覆盖
        他们的名字实际上是_classname__methodname。

__object__     #内建方法，用于魔术方法

2.方法:
# 三种方法获取类的属性和变量范围不同
实例方法
    定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；
    调用：只能由实例对象调用。
    范围：既可以获取构造函数定义的变量,也可以获取类的属性值
类方法
    定义：@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；
    调用：类和实例对象都可以调用。
    范围: 不能获取构造函数定义的变量,可以获取类的属性值
静态方法
    定义：@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；
    调用：类和实例对象都可以调用。
    范围：不能获取构造函数定义的变量，也不可以获取类的属性
example:如有一个学生类和一个班级类
        功能:执行班级人数增加的操作、获得班级的总人数
        这个问题用类方法做比较合适，为什么？因为我实例化的是学生，
        但是如果我从学生这一个实例中获得班级总人数，在逻辑上显然是不合理的。
        同时，如果想要获得班级总人数，如果生成一个班级的实例也是没有必要的。


# 三.继承原理
class.mro():所有基类的线性顺序列表
1.子类会先于父类被检查
2.多个父类会根据它们在列表中的顺序被检查
3.如果对下一个类存在两个合法的选择,选择第一个父类
obj.test()的查找顺序是，先从对象obj本身的属性里找方法test，没有找到，在所处类D的MRO列表来依次检索
"""


class Num:
    var = "类变量"
    _variable = "类私有变量"
    __num = 0

    # 普通方法：能用Num调用而不能用实例化对象调用,
    def one():
        print('1')

    # 实例方法：能用实例化对象调用而不能用Num调用,调用的时候会将该对象参数自动传入
    def two(self):
        print('2')

    # 静态方法：能用Num和实例化对象调用,因为没有传入cls和self所以不能修改类属性,可以传入相应参数做修改
    # 静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，逻辑上属于类，但是和类本身没有关系，也就是说在静态方法中，
    # 不会涉及到类中的属性和方法的操作。可以理解为，静态方法是个独立的、单纯的函数，它仅仅托管于某个类的名称空间中，便于使用和维护。
    @staticmethod
    def three():
        print('3')

    # 类方法：能用Num和实例化对象调用,第一个参数cls长什么样不重要，都是指Num类本身，调用时将Num类作为对象隐式地传入方法
    @classmethod
    def go(cls):
        cls.__num += 1
        cls.three()


Num.one()  # 1
# Num.two()         #TypeError: two() missing 1 required positional argument: 'self'
Num.three()  # 3
Num.go()  # 3
print(dir(Num))
if not hasattr(Num, 'var'):
    print("no")
else:
    print("yes")

i = Num()  # 类实例化
# i.one()           #TypeError: one() takes 0 positional arguments but 1 was given
i.two()  # 2
i.three()  # 3
i.go()
print('num', Num.mro())
"""
调用父类的三种方式
1.父类名称.父类方法名(self,参数1,参数2)
2.super().父类方法名(参数1,参数2)
# 多继承时候:super().父类方法名()更完美,python实现继承时候：会计算出一个所谓的方法解析顺序(MRO)列表，这个MRO就是基类的线性顺序表。
3.super(当前类名字,self).父类方法名(参数1,参数2)
3.super(当前类名字,当前类名字).父类方法名(参数1,参数2) # 里面获取类变量传入当前类名字
"""
