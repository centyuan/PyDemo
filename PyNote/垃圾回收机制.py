"""
gc.collect()手动出发回收机制
python垃圾回收机制:
1.引用计数机制为主
2.标记-清除 mark and sweep:首先标记对象（垃圾检测），然后清除垃圾（垃圾回收）
3.分代收集 generation collection:这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集
两种机制为辅的策略
"""

# 1.引用计数机制：(简单，实时)python里每一个东西都是对象，它们的核心就是一个结构体：PyObject
'''
(1:PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。
(2:对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少
(3:当引用计数为0时，该对象生命就结束了。
优点:简单,内存直接释放,实时性高,处理内存回收的时间分摊了
缺点:维护引用技术消耗资源,循环引用
'''

# 2.标记清除:基于追踪回收,分为标记阶段和回收阶段,解决了容器对象可能产生的循环引用问题
'''
1.基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发
2.遍历以对象为节点、以引用为边构成的图
(可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。)
把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。
缺点:必须扫描整个内存
'''


# 3.分带回收:建立在标记-清除基础上,以空间换时间的方法提高了垃圾回收效率
'''
将内存根据对象存活的时间分为不同的集合(年轻代:0,中年代:1,老年代:2),对应三个链表
1.新创建的对象分配在年轻代,年轻代链表总数达到上限会触发回收机制,可以回收的对象回收,不能回收的被移到中年代
2.老年代存活时间最长,甚至整个系统的生命周期
'''


