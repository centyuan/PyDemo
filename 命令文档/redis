# 一:基础命令
dbsize:查看当前数据库的key的数量
flushdb:清空当前数据库
flushall:清空所有库
keys *:查看当前库所有key
exists key:key是否存在
type key:查看key类型
del key:删除
unlink key:非阻塞删除,先将keys从keyspaces删除,真正的删除在后续异步操作中
expire key 10:设置10秒过期时间
ttl  key :-1表示永不过期,-2表示已过期



# 二：五大数据类型:String字符串,List列表,Set集合,Hash哈希,Zset有序集合

# 1.String 类型
String类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB
String:底层的数据结构为简单的动态字符串,类型Java的ArrayList,pyton list在第一次append也会超额分配,来减少频繁的内存分配

# nx上锁,ex设置过期时间
set cent bingxi nx ex 20
set cent bingxi
# 设置范围内的值
set range cent abc
# 设置和过期时间
setex cent 20 bingxi
# 新值换旧值
getset cent newbingxi
# 设置多个key value
mset k1 v1 k2 v2 k3 v3
# setnx key:不存在成功
setnx cent bingxi
# msetnx 设置多个:都不存在才成功
msetnx k11 v11 k22 v22
get cent
# 取多个key
mget k1 k2 k3
# 取值的范围
get range cent 0 3
# 值里面追加
append cent yuan
# 获取key长度
strlen cent
# 数字类型值加1  incr操作是原子性的:不会被线程调度机制打断
incr cent
# 数字类型加步长
incrby cent 10
# 数字类型值减1
decr cent
# 数字类型减步长
decrby cent 10
# 发布订阅
subscribe channel_yuan  # 订阅频道
publish channel_yuan helloworld # 推送消息到频道

# 2.List 类型
# List 是一个双向链表结构，单键多值,可以在头部或尾部插入数据性能高,操作中间值性能差
List底层的数据结构为:quicklist 在列表元素较少的情况下会使用一块连续的内存存储(ziplist，压缩列表),将多个ziplist链起来组成链表
:普通链表需要指针，比较浪费空间(只存int类型数据,结构上还要额外的prev,next)，redis List将多个ziplist使用双向指针串起来,即满足快速插入删除,又不会出现太大的空间冗余

# 从左边插入一个或多个 ###从左边结果为n a u y
lpush cent y u a n
# 从右边插入一个或多个 ###从右边结果为y u a n
rpush cent y u a n
#从左边/右边吐出一个值
lpop/rpop key
# 从key1列表右边吐出一个值,插到key2列表左边
rpoplpush key1 key2
lrange cent 1 4:取值  ### 0 -1:取所有
# 按照索引下表获得元素
lindex cent 2
# 获取列表长度
llen cent
# 在列表value值后面或前面插入一个新值
linsert cent after/before <value> <new_value>
# 将列表2的位置的值替换成newvalue
lset cent 2 newvalue
#
lrem <key> <n> <value>


# 3.Hash是一个键值(field=>value)对映射表 特别适合用户存储对象,每个 hash 可以存储 232 - 1 键值对（40多亿）
# 对应数据结构有两种,ziplist(压缩列表),hashtable(哈希表),当field-value长度较短个数较少,使用ziplist,否则使用hashtable
当hash对象可以同时满足一下两个条件时，哈希对象使用ziplist编码：
1.哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
2.哈希对象保存的键值对数量小于512个
使用ziplist的优点:
相比hashtable,ziplist结构减少了指针,节约了内存
相比linklist,ziplist存储时内存分配是连续的,查询更快
ziplist如何实现hash存储的:
将同一个键值对的两个节点紧挨着保存,保存键的节点在前,保存值的节点在后,新加入的键值对,放在压缩列表表尾

# 添加数据
hset <key> <field> <value>
# 取出数据
hget <key> <field>
# 批量设置多个值
hmset <key> <field1> <value2> <field2> <value2>
# 查看hash中field是否存在
hexists <key> <field>
# 查看hash中所有field
hkeys <key>
# 查看hash中所有value
hvals <key>
# hash对应field加上n
hincrby <key> <field> n
# 添加hash中对应field:当field不存在时
hsetnx <key> <field> <value>


# 4. Set集合:无序,不重复
# 和List类似,特殊是自动去重的,是string类型的无序集合,底层其实是一共value为null(所有value指向同一个内部值)的hash表即HashMap实现,
# 所有添加,查找,删除的复杂度都为O(1)

# 添加，第二次插入相同元素将被忽略
sadd <key> <value1> <value2>
# 取集合所有值
smembers <key>
# 判断值是否在集合中,有返回,无返回0
sismember <key> <value>
# 返回集合元素个数
scard <key>
# 删除集合中某些值
srem <key> <value1> <value2>
# 随机吐出一个值
spop <key>
# 随机从集合取出n个值
srandmember <key> n
# 把集合中某个值移动到另一个集合
smove <source> <destination> value
# 返回两个集合的交集
sinter <key1> <key2>
# 返回两个集合并集
sunion <key1> <key2>
# 返回两个集合的差集,key1中的,不包含key2的
sdiff <key1> <key2>


# 5.Zset:有序集合,不重复
# Zset集合元素关联一个评分(score),score被用来从最低到最高排序,元素唯一,score可以重复
#底层使用了两个结构:1.hash,关联value和权重score,保障元素value的唯一性,通过value可以找到score
                  2.跳跃表,在于给元素value排序,根据score范围获取元素列表
# 添加元素
zadd <key> <score1> <value1> <score2> <value2>
# 取出所有值
zrange <key> 0 -1
# 取出值和评分
zrange <key> 0 -1 withscores
# 取出评分在min,max之间的值
zrangebyscore <key> min max          # zrevrangebyscore 从大到小
# 增加value对应的score n
zincrby <key> n <value>
# 删除
zrem <key> <value>
# 统计score在min,max之间元素个数
zcount <key> min max
# 返回value对应的排名 从0开始
zrank <key> <value>

# 6.redis6的新数据类型
Bitmaps实现了对位的操作字符串
# 设置值 key 偏移量
setbit <key> offset 1
# 取值
getbit <key> offset

HyperLogLog用来做基数统计
Geospatial用来经纬度


# 三:Redis的事务multi和管道pipeline
First:redis事务transaction:
单独的隔离操作:事务在执行过程中,不会被其他客户端发送来的命令请求所打断,分为三个阶段:开始事务,命令入队,执行事务
单个redis命令是原子性的,但redis没有在事务上增加任何维持原子性的机制,所以 Redis 事务的执行并不是原子性的，
事务可以理解为一个打包的批量执行脚本(),但批量指令并非原子性的操作,中间某条指令的失败不会导致前面已做指令的回滚,也不会造成后续的指令不做。
1.命令执行异常情况:命令执行时候出现异常,不影响其他命令的执行。
2.指令或参数错误:命令入队失败,整个事务被取消。

# 1.multi开启事务
multi
# 2.多个命令(入队时:命令失败,其他命令都不会执行)
SET book_name "c++ plus"
SADD tag "C++" "Programming" "Mastering Series"
# 3. EXEC执行事务(执行时:命令失败,不影响其他命令)
EXEC
# 4.discard 取消事务
# 5.WATCH、UNWATCH在事务中用于乐观锁

Second:管道（pipeline）
redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务,默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作
通常一个请求会遵循以下步骤:
1.客户端向服务端发送一个请求,并监听Socket返回,通常是阻塞模式,等待服务响应
2.服务端处理命令,并将结果返回客户端
管道（pipeline）是redis在提供单个请求中缓冲多条服务器命令的基类的子类。它通过减少服务器-客户端之间反复的TCP数据库包，从而大大提高了执行批量命令的功能。
如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令,不具有原子性

Third:Redis事务与pipeline区别
pipeline选择客户端缓冲,multi选择服务端缓冲
multi需要每个命令都发送一次服务端,pipeline最后一次发送服务端

# 四:配置文件说明
redis-server /etc/redis/redis.conf
# 1.开启远程访问
注释bind 127.0.0.1
关闭保护模式:protected-mode no
# 2.高并发提升客户端连接,改成更大的值
# tcp-backlog未完成三次握手队列+已完成三次握手队列
tcp-backlog 511
# 3.连接超时配置 0为永不超时,秒为单位
timeout 0
# 4.tcp-keepalive
# 300秒执行一次心跳检测,来决定是否释放连接
tcp-keepalive 300
# 5.设置密码
requirepass 123456
conig set requirepass 123456   # 命令设置
# 6.设置客户端最大连接数
maxclients 10000
# 7.后台启动
修改redis.conf:daemonize yes
#多实例关闭,指定端口关闭:redis-cli -p 6379 shutdown
# 8.哨兵模式配置优先级 值越小优先级越高
slave-priority 100

# 五:Redis持久化方案RDB-AOF
AOF备份文件异常恢复:
appendonly no 改为yes
redis-check-aof--fix appendonly.aof 进行恢复

# 六:Redis集群
1.主从复制
2.哨兵
3.Cluster

#1.主从(一主二从,薪火相传,反客为主)
从服务挂了,重启之后变成master需要手动slaveof加入,然后会同步主服务器数据,主服务挂了,重启不影响主从之间关系
从服务下还可以设置从服务,手动:slaveof no one主服务挂了,从服务变为主服务.
#1.创建/myredis文件夹
#2.创建redis6379.conf,redis6380.conf,redis6381.conf
#3.修改各自配置文件
include /myredis/redis.conf
pidfile /var/run/redis_6379.pid
port 6379
dbfilename dump6379.rdb
#4.启动几个redis redis-server /myredis/redis6379.conf
#5.查看主从情况:info replication
#6.设置主从:slaveof 127.0.0.1 6379
# 主从同步:
1.第一次从服务连上主服务器后,向主服务器发送数据同步请求
2.主服务器数据持久化到RDB文件,将RDB文件发送到从服务器进行同步
3.每次主服务器写操作后,主动将数据同步到从服务器

#2.哨兵模式
1.选择优先级靠前的2.选择偏移量最大的(偏移量指获得原主机数据最全的)3.选择runid最小的从服务(Redis实例启动后随机生成一个40位的runid)
# 创建sentinel.conf
sentinel monitor mymaster 127.0.0.1 6379 1
mymaster:为监控对象起的名称,1为至少有多少哨兵同意
# 启动哨兵
redis-sentinel /myredis/sentinel.conf


#3.Cluster集群配置(16384个插槽,写入数据,计算key的插槽分配到对应主服务所在的插槽)
# 集群实现扩容,集群不支持多键操作
1. 每个redis.conf加上集群配置
cluster-enabled yes                   # 打开集群
cluster-config-file nodes-6379.conf   # 设置节点配置文件名
cluster-node-timeout 15000            # 设置节点失联时间单位为毫秒,超过该时间,集群自动进行主从切换

2.启动每个Redis实例 redis-server /myredis/redis.conf,确保nodes-xxxx.conf等文件都生成
3.在redis src下执行依赖ruby环境,实现redis实例合成集群
# 1.表示一主一从
redis-cli --cluster create --cluster-replicas  1 ip:port ip2:port2
# 集群连接-c
redis-cli -c -p 6379
# 查看集群状态
cluster nodes
# yes为某一段插槽的主从挂了,整个集群都挂掉.no为某一段插槽主从挂了,该插槽数据不能使用
cluster-require-full-coverage yes


# 七:Redis分布式锁
互斥性,不会发送死锁,谁的锁谁解锁,加锁解锁保证原子性
实现分布式锁:SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]
# nx:设置锁,ex设置过期时间:确保自动释放锁,防止死锁,delete手动释放锁
set lock bingxi nx ex 20
# 问题:某个操作超时,手动会误删其他操作的锁? uuid可以防止锁误删
通过value的uuid来标识不同操作的锁,判断自己删自己的锁
set lock uuid
# 问题:(没有原子性)已经判断了uuid,正要手动delete正要删除时,锁过期时间到了自动删除了,其他操作获取到锁了,原来操作在删除会删除原来的锁
使用lua脚本判断uuid在删除,保证原子性

# 八:Redis常见问题
Redis缓存问题?
1.缓存穿透(访问大量缓存不存在的数据(和不存在的空值),缓存命中率降低了)
一:对空值进行缓存,设置较短的过期时间
二:通过bitmaps设置可访问的白名单
三:使用布隆过滤器
2.缓存击穿(热门key过期了)
一:预先设置热门数据,设置较大的过期时间
二:实时调整
3.缓存雪崩(缓存大批量失效或者宕机)
一:构建多级缓存架构和redis集群
二:分散过期时间
三:限流降级

Redis为什么这么快?
redis是:基于内存的k-v数据库+简单的数据结构+单线程(省去上下文切换和各种锁的问题)+多路IO复用技术
单线程:基于Reator模式开发了自己的网络事件处理器(文件事件处理器是单线程的)

Redis为什么是单线程?
CPU不是redis的瓶颈,不会有太多的计算和逻辑判断,最有可能机器内存和网络带宽

Redis6.0为什么引入了多线程?
瓶颈在网络I/O模块带来的CPU耗时,引入的多线程用来处理网络I/O部分。

是否有并发安全问题?
内存操作，依然是单线程运行的。edis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行，也就不存在并发安全问题

如何开启多线程？
配置文件开启多线程：
io-thread-do-reads yes
io-thread 线程数



###############Redis ACL#############################