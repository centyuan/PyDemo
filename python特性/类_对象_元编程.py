
# __init__和__new__
"""
__init__(self, *args, **kwargs):
初始化方法,给类的实例进行初始化属性，可以不用返回值
创建类的实例时自动调用,自定义类没有,默认调用父类的
__new__(cls, *args, **kwargs):
构造方法用于给类创建一个实例对象，并返回
实例化最先调用,先于__init__执行
return super().__new__(cls)
return object().__new__(cls)
"""

# 动态属性创建是一种元编程




# 特性都是类属性,但是特性的管理其实是实例属性的存取,@property装饰器用于将方法转换为相同名称的只读属性

class test:
    def __init__(self) -> None:
        self.__num = 0
    @property
    def num(self):
        return self._num
    # 用于设置修改值
    @num.setter
    def num(self,value):
        # 类型检查
        if not isinstance(value, int):
            raise TypeError("Expected a int")
        self.__num = value
    @num.deleter
    def num(self):
        del self.__num

# 处理属性的内置函数
"""
dir,setattr,hasattr,getattr,vars(类定义了__slots__，导致实例没有__dict__属性,则vars不能处理),locals()
__slots__=['a']:
是python类的魔法属性,接受一个iterable对象作为属性
定以后,该类实例只能创建__slots__中声明的属性。
优点:
1.节省内存
没有__slots__,实例属性管理依赖__dict__字典
定义__slots__,实例属性管理依赖__slots__,实例不在拥有__dict__属性
__dict__字典在内存分配会预留较大的内存空间
__slots__则按照其中声明的属性分配定长内存
2.更快的访问速度
使用__slots__访问属性,节省了一次哈希的过程
"""
# hasattr(),getattr(),setattr(),delattr()一组内置函数,用于对象的属性操作
"""
hasattr(obj,name):函数用于判断是否包含对应的属性,返回True 或False
getattr(obj,name,default):函数用于返回一个对象属性值
setattr(obj,name,value): 用于设置属性值
delattr(obj,name):用于删除属性
"""

# 处理属性的特殊方法
"""
__getattribute__: 尝试获取指定的属性时调用,寻找的属性是特殊属性和特殊方法除外，失败异常才会调用__getattr__
__getattr__
__setattr__
__delattr__
__dir__
"""

# 下划线,静态方法和类方法
"""
# 一:变量/类属性
1.类属性只有一个:
所有实例都可以访问类属性，且访问的类属性是同一个，一旦类属性改变就会影响到所有的实例。
2.变量:
在Python中，有以下几种方式来定义变量：
xx：公有变量
_xx：单前置下划线，被看作是“protect”化属性或方法(1.约定仅供内部使用,不强制,2.(模块内部使用)from somemodule import *禁止导入)
__xx：双前置下划线，被看作是"private”化属性或方法(无法在外部直接访问只能内部访问（名字重整所以访问不到,实例对象._类名__变量名可强制访问）)
__xx__：双前后下划线，系统定义名字（不要自己发明这样的名字）
xx_：单后置下划线，用于避免与Python关键词的冲突


# 二:函数/方法
1.方法作用域
object:公用方法

_object:半保护
    被看作是“protect”,约定只能类对象和子类对象自己能访问到这些变量(不强制)
    不能用’from module import *’导入(通配符导入),则模块外不能使用(可以指定导入)

__object:全私有，全保护
    私有成员“private”，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据，不能用’from module import *’导入。
    __object 是为了避免与子类的方法名称冲突， 对于该标识符描述的方法，父类的方法不能轻易地被子类的方法覆盖
    他们的名字实际上是_classname__methodname。

__object__:内建方法，用于魔术方法

2.方法:
# 三种方法获取类的属性和变量范围不同
实例方法
    定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；
    调用：只能由实例对象调用。
    范围：既可以获取构造函数定义的变量,也可以获取类的属性值
类方法
    定义：@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；
    调用：类和实例对象都可以调用。
    范围: 不能获取构造函数定义的变量,可以获取类的属性值
静态方法
    定义：@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；
    调用：类和实例对象都可以调用。
    范围：不能获取构造函数定义的变量，也不可以获取类的属性
example:如有一个学生类和一个班级类
        功能:执行班级人数增加的操作、获得班级的总人数
        这个问题用类方法做比较合适，为什么？因为我实例化的是学生，
        但是如果我从学生这一个实例中获得班级总人数，在逻辑上显然是不合理的。
        同时，如果想要获得班级总人数，如果生成一个班级的实例也是没有必要的

# 三.继承原理
class.mro():所有基类的线性顺序列表
1.子类会先于父类被检查
2.多个父类会根据它们在列表中的顺序被检查
3.如果对下一个类存在两个合法的选择,选择第一个父类
obj.test()的查找顺序是，先从对象obj本身的属性里找方法test，没有找到，在所处类D的MRO列表来依次检索

# 四.调用父类方法

调用父类的三种方式
1.父类名称.父类方法名(self,参数1,参数2)
2.super().父类方法名(参数1,参数2)
# 多继承时候:super().父类方法名()更完美,python实现继承时候：会计算出一个所谓的方法解析顺序(MRO)列表，这个MRO就是基类的线性顺序表。
3.super(当前类名字,self).父类方法名(参数1,参数2)
3.super(当前类名字,当前类名字).父类方法名(参数1,参数2) # 里面获取类变量传入当前类名字
"""