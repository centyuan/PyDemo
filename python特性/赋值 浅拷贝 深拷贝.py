# ！/usr/bin/python3
# -*- coding:utf-8 -*-
# author centyuan
# @time 19-9-10 下午3:00
import copy

"""
直接赋值：其实就是对象的引用（别名）。
a[:]切片是浅拷贝

"""
# 一：浅拷贝
# 浅拷贝:拷贝父对象，不会拷贝对象的内部的子对象(父对象不是同一引用了，内部的子对象还是同一个引用)
a = {1: [1, 2, 3]}
b = a.copy()
print(a, b)

a[1].append(4)
print(a, b)

a[2] = [7, 8, 9]
print(a, b)
# 二:深拷贝
# 深拷贝:copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象(完全独立，不存在相同引用)

c = copy.deepcopy(a)
print(a, c)
a[1].append(6)
print(a, c)

# 三:赋值
"""
解析：
1.赋值
 b = a ,a和b都指向同一个对象，是直接引用
# 例外情况
lis1 = [1,2,3]
lis2 = lis1[:]  # 这种情况赋值，lis1,lis2就不是同一引用了
print(id(lis1)==id(lis2)) # False

2.浅拷贝
 b = a.copy()  a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）
 
3.深拷贝
 c = copy.deepcopy(a)  深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的
"""
# 四:is == 区别
# is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。
a = 257
b = 257
print("a is b:", a is b)

"""
#first:在 Python 中会实现创建一个小型的整形池，范围为 [-5,256]，为这些整形开辟好内存空间，当代码中定义该范围内的整形时，不会再重新分配内存地址
seconde:后来查了资料才发现是：Python出于对性能的考虑，但凡是不可变对象，在同一个代码块中的对象，只有是值相同的对象，就不会重复创建，而是直接引用已经存在的对象。
"""

t1 = (1, 2, 3)
t2 = t1[:]
print(t1 is t2)  # 不可变对象是同一对象

lis1 = [1, 2, 3]
lis2 = lis1[:]
print(lis1 is lis2)  # 可变对象 不是同一对象
