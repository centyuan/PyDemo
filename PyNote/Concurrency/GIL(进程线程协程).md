---
title: GIL/进程线程协程切换
categories:
   - Python从入门到放弃
tags:
   - GIL
---



#### GIL

>Global interperter Lock全局解释器锁,并不是Python特性,CPython引入的概念，python完全可以不依赖GIL
>
>**为什么使用GIL?**
>
>每个线程在执行过程中都要先获取GIl，保证同一时刻只有一个线程运行,目的是解决多线程之间的数据完整性和状态同步,
>
>并且因为使用引用技术管理内存，所以某个对象的引用计数不能被两个线程同时增加和减少，不然造成内存泄露,GIL对线程间共享的所有数据结构加锁可以保证引用计数变量的安全性
>
>导致python的多线程在多核CPU上，只对IO密集型产生正面效果,对应CPU密集型，多线程效率会因为GIL而大幅下降
>
>**GIL锁的释放**
>
>```
>1.协同式多任务处理(IO密集型任务)
>在较长的或者不确定的时间(IO阻塞，python标准库中所有阻塞性I/O和time.sleep()都会释放)，没有运行Python代码的需要，线程便会让出GIL
>
>2.抢占式多任务(CPU密集型任务)
>解释器运行一段时间就主动释放GIL,这种机制叫间隔式检查(check_interval),每隔一段时间Python解释器就会强制当前线程释放GIL而不需要正在执行代码线程调度允许(python3中，这个时间间隔是15毫秒)
>```
>
>**GIL缺陷**
>
>```
>1.抢占式多任务处理(CPU密集型):(每个线程在多个cpu交替执行:cpu调度线程唤醒->去拿GIL->没拿到->在等待:1.线程上下文切换,2.争抢不到GIL会让cpu等待,都浪费cpu时间)
>2.Python的每个版本中也在逐渐改进GIL和线程调度之间的互动关系。例如先尝试持有GIL在做线程上下文切换，在IO等待时释放GIL等尝试。
>3.但是无法改变的是GIL的存在使得操作系统线程调度的这个本来就昂贵的操作变得更奢侈了
>```
>
>

#### CPU上下文

>CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境
>
>1. CPU寄存器是CPU内置的小容量高速的内存
>2. 程序计数器用来存储CPU正在执行的指令位置,或者将执行的下一条指令位置



##### CPU上下文切换

>1.把前一个CPU上下文(CPU寄存器和程序计数器)保存起来
>
>2.加载新任务的上下文到CPU寄存器和程序计数器
>
>3.调到程序计数器所指位置，运行新任务

##### CPU上下文切换类型

>进程上下文
>线程上下文
>中断上下文

#### 内核空间和用户空间

>内核空间(Ring 0): 具有最高权限,直接访问所有资源
>
>用户控件(Ring 3): 只能访问受限资源,不能直接访问内存等硬件设备，必须通过系统调用到内核空间才能访问这些特权资源
>
>进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态
>
>**用户态内陷内核态三种方式**
>
>系统调用,异常,中断



#### 系统调用

>比如查看文件内容就需要系统调用:open()打开文件,read()读取文件内容,write()将文件内容写到标准输出
>
>过程：
>
>```
>1.保存CPU寄存器原来用户态的指令位
>2.为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置
>3.跳转到内核态运行内核任务
>4.系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程
>一次系统调用的过程，其实是发生了两次 CPU 上下文切换。（用户态-内核态-用户态）
>要注意的是：系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行
>所以，系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换。
>```



#### 进程上下文切换

```
虚拟内存:当内存耗尽时,自动调用硬盘充当内存
Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系
```

>首先：**进程是由内核来管理和调度的，进程的切换只能发生在内核态**
>
>进程的上下文：不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态
>
>因此：**进程的上下文切换就比系统调用时多了一步**
>
>**在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈**
>
>**导致进程上下文切换的情况**
>
>```
>1.CPU时间被耗尽
>2.系统资源不足，需要等到资源满足才可以运行
>3.进程通过sleep这样的方法主动挂起
>4.有更高的优先级进程
>5.硬件中断
>```
>
>`进程状态:`
>   1.运行running
>   2.就绪ready
>   3.等待wait



#### 线程上下文切换

>线程本身是共享进程的虚拟内存和全局变量等资源，这些资源在上下文切换时不需要修改，不涉及虚拟地址的变化，这就是为什么进程切换比线程切换开销大的原因
>
>**所以线程的切换就只包括线程上下文的切换，就是替换线程放在处理器寄存器中的相关私有数据，但是线程的调度也需要到内核空间完成,同样需要从用户态转向内核态**
>
>`线程状态`
>   1.创建new(分配资源，初始化)
>   2.就绪ready
>   3.执行running(获取CPU时间,执行代码)
>   4.阻塞blocked(放弃CPU,暂停运行,常见阻是原因:等待I/O操,等待锁,等待其他线程通知)
>   5.终止terminated()



#### 协程切换

> ```
> 协程:是一种比线程更加轻量级的微线程，一个线程也可以拥有多个协程
> ```
>
> **协程切换完全在用户空间进行**，协程拥有自己的寄存器上下文和栈，协程调度切换时，
> 将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，
>
> 当前协程的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上就 ok 了,在用户空间不涉及内核空间

#### 进程线程区别

>1根本区别:资源分配的基本单位,cpu调度执行的基本单位
>2地址空间:空间资源独立,共享本进程的空间和资源
>3键壮性:崩溃不影响其他进程,一个线程崩溃整个进程崩掉
>4执行过程:进程有(执行入口/顺序执行/执行开销大),线程不能独立运行(依附于进程,执行开销小)
>5切换:进程切换资源消耗大,线程切换消耗小
>(进程切换需要切换页表,页表切换后,TLB失效,地址转化时需要重新查找页表。线程切换不需要切换页表)


