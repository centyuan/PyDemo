mysql:单进程多线程模型,一个SQL语句无法利用多个cpu core
# 一:基本命令
0.查看当前连接数
show global status like 'Thread$';
1.查看当前连接状态
show processlist;
2.数据库连接
mysql -h 主机名 -u root -p
3.添加用户
insert into user (host,user,password,select_priv,insert_priv,update_priv) values ('localhost','guest',password('guest123'),'Y','Y','Y');
4.创建用户
create user 'username'@'host' identified by 'password';
create user 'username'@'%' identified by 'password';
###新创建用户无法登陆问题
use mysql；
delete from user where user='';
flush privileges;
# 对db_name下所有表都有查询(SELECT)权限
grant select on db_name.* to 'username'@'%';
# 对所有表有全部权限
grant all on *.* to 'username'@'%';
5.删除用户
drop user 'username'@'host';
6.修改用户密码
set password for 'username'@'host' = password('123password');
update user set password=password("你的新密码") where user="root";
7.创建数据库病设置字符集和排序规则
create database data_name;
create database data_name character set utf8 collate utf8_general_ci;
8.删除数据库
drop table data_name;

# 二:操作命令
1.显示表属性
desc user_table;
show columns from user_table;
2.显示数据表的索引信息
show index from user_table;
3.显示数据库所有以run开头的表信息
show table status like'run%';
4.创建表,engine=指定存储引擎,每张表都可以指定存储引擎
create table 'run_tb'(
    'run_id',int unsigend auto_increment,
    'run_title', varchar(100) not null,
    'run_author',varchar(40) not null,
    'sub_data',date,
    primary key('run_id')
)engine=innodb default charset=utf-8;
5.插入数据
insert into table_name(field1,field2,field3,field4) values(value1,value2,value3,value4);
6.更改字段类型
alter table system_info modify column ip varchar(100) ;
7.更改字段为非空
alter table system_info alter column ip set not null;
8.添加字段
alter table system_info add email varchar(30);
9.删除字段
alter table system_info drop column email;
10.字段改名
alter table system_info rename email to new_email;
11.清空表或删除记录
delete from table_name; 或 delete from table_name where id=1;
12.插入记录
insert into table_name(field1,field2,field3) values(value1,value2,value3);
13.更新记录
update table_name set field2="张三" where id =3;
14.修改表名
alter table table_name rename to new_table_name;
15.模糊查询,%表示任意字符
select *  from Student where name like "%三%"
16.多条件查询and,or
select * from Sudent where age between 18 and 50;
select * from Student where age >18 and age <60 and address='上海'
17.去重
select distinct address from Student;
18.排序:asc升序,desc倒序
select * from Student order by age desc;
19.查询上做计算
select age*3 name from Student;
20.最大max,最小min,平均avg,求和sum,个数count
select count(id) from Student;
21.分组查询 group by 将某一列相同数据视为一组
使用了group by,select后只能跟分组列和聚合函数
查询人数大于3的地区的最大年龄
select address,max(age) from Student group by address having count(*)>3;
22.分页
select * from Student limit 3,5; # 从第三条记录,查询五条
select * from Student limit (n-1)*m,m; # 第n也查询m条记录
23.join连表查询 on 条件
select Sites.id,Sites.name,Log.count,Log.date from Sites inner join Log on Sites.id=Log.site_id;


三: 复制,导入导出数据

# 1.复制n条记录并创建
INSERT into reyo (num,overtime) SELECT num,overtime from reyo where id IN(1,3,5,6,7,9);
INSERT into reyo (`num`,`overtime`) SELECT `num`,`overtime` from reyo where id IN(1,3,5,6,7,9);

# 2.导出整个数据库
mysqldump -u root -p dbname>dbname.sql
# 3.导出表 show variables like '%secure%'查看安全目录
mysqldump -u root -p dbname users>dbname_users.sql
SELECT * FROM runoob_tbl  INTO OUTFILE '/var/lib/mysql-files/Dbug_manangement.txt';
SELECT * FROM users  INTO OUTFILE '/var/lib/mysql-files/users.sql';
# 4.导入备份的整个数据库
mysql -u root -p < Detector.sql     # 需要再sql文件创建或指定数据库
mysql>source /home/abc/abc.sql      # 进入数据库下use Detector
# 5.插入数据到某个表
load data local infile "/var/lib/mysql-files/CaseUrl.sql" into table CaseUrl;
load data local infile "/var/lib/mysql-files/CaseUrl.sql" into table CaseUrl
(id,name, url, status_code, result, processresult, proposal,@create_time,test_time,case_id) FIELDS TERMINATED BY ', '
set create_time=DATE_FORMAT(@create_time,"%Y-%m-%d %H:%i:%s")








# 四:mysql性能优化(四个维度:1.架构,2.硬件,3.DB优化,4.sql优化)
架构:集群读写分离,数据库切分
硬件:高效的磁盘读写性能
DB:参数优化(日志不能笑,缓存足够大,连接够用)
my.ini或my.cnf配置文件
sort/join/read/rnd buffer:4M或8M或16M
tmp/heap table:96M或128M
innodb_flush_log_at_trx_commit:对redo日志刷盘频率的设定
当 innodb_flush_log_at_trx_commit 取值为 0 的时候，log buffer 会 每秒写入到日志文件并刷写（flush）到磁盘。但每次事务提交不会有任何影响，也就是 log buffer 的刷写操作和事务提交操作没有关系。在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。
当取值为 1 时，每次事务提交时，log buffer 会被写入到日志文件并刷写到磁盘。这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢。
当取值为 2 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。
sync_binlog:binlog刷盘的频率
######innodb_flush_log_at_trx_commit和sync_binlog设置为1来保证主库和主从库的一致性
long_query_time:sql执行时间限制
interactive_timeout:交互模式下超时时间,五分钟或十分钟
lock_wait_timeout:表锁锁定时间
time_zone:使用datetime减少性能消耗
wait_timeout:程序连接mysql超时时间,五分钟或十分钟
innodb_buffer_pool_size:缓冲池大小(越大,磁盘I/O减少)2个G左右
innodb_buffer_pool_instances:配置多个缓冲池实例
tmp_table_size:临时表的最大大小

explain检查sql语句
sql优化:
1.合理使用索引
2.使用UNION ALL(不去重,所有数据)替代UNION(去重后)
3.多用limit
4.用连接查询代替子查询
5.选择合理的字段类型
6.join表不宜过多
7.避免索引失效

### 索引失效情况
（1）：like以%开头索引无效，当like以&结尾，索引有效。
（2）：or语句前后没有同时使用索引，当且仅当or语句查询条件的前后列均为索引时，索引生效。
（3）：组合索引，使用的不是第一列索引时候，索引失效，即最左匹配规则。
（4）：数据类型出现隐式转换，如varchar不加单引号的时候可能会自动转换为int类型，这个时候索引失效。
（5）：在索引列上使用IS NULL或者 IS NOT NULL 时候，索引失效，因为索引是不索引空值得。
（6）：在索引字段上使用，NOT、 <>、！= 、时候是不会使用索引的，对于这样的处理只会进行全表扫描。
（7）：对索引字段进行计算操作，函数操作时不会使用索引。
（8）：当全表扫描速度比索引速度快的时候不会使用索引。
（9）：使用了select *(不会走索引,大量的回表操作)。


# 五:索引详解
磁盘I/O:每次读取n*块个单位大小到内存
二叉查找树->AVL平衡二叉树->B-Tree->B+Tree
B-Tree:多路平衡二叉树,每个节点包含多对(子节点指针,键key,值data),相比于AVL缩减了节点数,减少了树的高度
B+Tree:非叶子节点(双向链表)只存储key键,值data顺序存在同一层的叶子节点上,相比于B-Tree每个节点能存储更多的key,减少了树的高度和磁盘I/O次数
1.什么是索引?
对一列或多列值进行排序的数据结构()
2.mysql有哪些索引?
主键索引(聚簇索引,唯一索引unique唯一且不为NULL),复合索引(最多包含16列:where多条件最左原则),全文索引(char、varchar，text 列上可以创建全文索引,一般不使用,不是mysql专长)
普通索引,空间索引(对空间数据类型字段建立索引,mysql有四种:GEOMETRY,POINT,LINESTRING,POLYGON)
聚簇索引:节点存储索引和数据,找到索引就找数据
非聚簇索引:节点值存储索引和数据地址
InnoBD索引采用B+的聚簇索引
MyISAM索引采用B+的非聚簇索引

# 六:mysql预编译(sql执行前会进行解析和校验)
场景:SQL语句一样,参数不一样,可以对SQL语句预编译
sql语句执行流程:
连接层->服务层->引擎层->存储层
sql语句->查询缓存(默认关闭不推荐使用,sql语句必须相同,切表数据表动大)->语法解析预处理器(检查是否有语法错误)->优化器->执行器
语法:prepare name from statement;
1定义.prepare statement_1 from 'select * from user where id=?'; # 通过?进行占位
2参数.set @id=2;
3执行.execute statement_1 using @id;


# 七:sql注入预防
1.不信任用户提交的数据(参数过滤,严格检查参数类型,转义,限制长度)
2.mysql预编译(参数化查询,变量绑定)

# 八:InnoDB和MyISAM区别
MyISAM:支持表级别锁(限制了读/写的性能),不支持事务,拥有较高的插入和查询速度,B+的非聚簇索引,通常用于只读或以读为主的场景.
怎么快速向数据库插入100万条数据?先用MyISAM插入数据,然后修改存储引擎为InnoDB
InnoDB:支持行/表级别锁,支持事务/外键(数据的完整性和一致性更高),采用B+的聚簇索引,通常用于经常更新的场景.

# 九:WAL技术(Write-Ahead Logging)RedoLog(对所有页面的操作写入日志文件,实现事务的持久性)
Buffer Pool(Log Buffer)

操作系统和内存:最小单位是页page
操作系统和磁盘:最小单位是块block

https://baijiahao.baidu.com/s?id=1711883948686737820&wfr=spider&for=pc
https://www.cnblogs.com/MoonYear530/p/13698324.html#:~:text=%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%9C%A8%E5%8E%9F%E6%9C%89%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%B8%AD%EF%BC%8C%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%A1%AB%E5%85%85%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%86%8D%E5%B0%86%E5%8F%82%E6%95%B0%E5%80%BC%E4%BC%A0%E5%85%A5%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E3%80%82%20%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%A2%AB%E8%B0%83%E7%94%A8%E8%AF%AD%E5%8F%A5%E5%8F%AA%E8%A2%AB%E7%BC%96%E8%AF%91%E4%B8%80%E6%AC%A1%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E4%BC%A0%E5%8F%82%E3%80%82%20%E6%AF%94%E5%A6%82%E4%B8%8B%E9%9D%A2%E8%BF%99%E6%9D%A1%E8%AF%AD%E5%8F%A5%EF%BC%9A%20sql%20%3D%20%22UPDATE%20%60transaction%60%20SET,%28customer_id%29s%20%E4%B9%9F%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9A%84%EF%BC%8C%E9%80%9A%E8%BF%87%20execute%20%28sql%2C%20data_tuple%29%20%E8%83%BD%E5%A4%9F%E6%9C%89%E6%95%88%E5%9C%B0%E9%98%B2%E6%AD%A2%20SQL%20%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%8C%E5%BD%93%E7%84%B6%E5%AE%83%E6%9C%89%E6%9B%B4%E5%A4%9A%E5%85%B6%E4%BB%96%E5%A5%BD%E5%A4%84%E3%80%82
mysql acid实现原理
https://blog.csdn.net/qq_40634846/article/details/122226371