>title: 算法与数据结构

>时间复杂度: 操作次数的表达式,不要低阶项,不要高阶项的常数



**异或运算**

>相同为0，不同为1
>
>1. 0^N=N  N^N=0
>
>2.异或运算满足交换律和结合律
>
>**通过异或运算交换两个值(两个值是不同变量)**
>
>a = a ^b
>
>b = a^b
>
>a = a^b
>
>**提取最右侧的1**
>
>right_one = e or &(~e or+1)

>二分时间复杂度: log(N)
>
>mid = L + (R-L)/2   //防止值溢出
>
>mid = L + (R-L)>>1  //右移1位类似除2

#### 排序

>稳定性:值相同的，排序后位置不变(基础数据类型没用)

**选择排序 **不稳定

>0-n中找最小值交换到第1位
>
>1-n中中最小值交换到第2位
>
>...
>
>时间复杂度O(n^2),数据好坏情况都是O(n^2)

**冒泡排序** 稳定

>从1开始(1和2)两两相比较,大的交换到后面，一直到n,最大的会在n上
>
>从1开始两两比较,大的交换到后面,一直到n-1,次大的在n-1上
>
>...
>
>时间复杂度O(n^2),数据好坏情况都是O(n^2)

**插入排序-最重要** 稳定 

>0到0有序，一直和前面比较，较小就交换到前面，直到前面没有比它还小
>
>0到1有序
>
>0到2有序
>
>...
>
>时间复杂度O(n^2),数据情况较好可以做到O(n)

**归并排序 **稳定

>左边有序，右边有序，在合并merge(左侧小copy左边,右边小copy右边)，使用递归
>
>mid = L +（R-L)/2
>
>process(arr,L,mid)  # 左侧有序
>
>process(arr,mid,R)  # 右侧有序
>
>merge(arr,L,mid,R)
>
>时间复杂度: O(nlogn)
>
>扩展:小和问题/逆序对问题

**快速排序** 不稳定 经过实验常数项是最小的,，优先使用

>荷兰国旗问题
>
>第一版本:
>
>取最后一个数为num，让小于num在左边，大于num在右边,右边第一个和num交换
>
>依次在左右两部分重复上面递归过程
>
>第二版本:
>
>取最后一个数为num，让小于num在左边，大于num在右边,等于num在中间,右边第一个和num交换
>
>一二版本都是O(n^2) partition
>
>第三版本:
>
>随机选一个值交换到最后，后面和一二版本一样(好情况和坏情况等概率事件)
>
>O(nlogn)

**堆排序-重要 **不稳定

>先构造一个大根堆
>
>堆顶和最后一个位置交换,堆heapsize-1(断开最后一个位置和堆的连接)
>
>依次调整堆变为大根堆,在重复上面过程
>
>

>堆结构:逻辑上一个完全二叉树，分为大根堆/小根堆
>
>数组影射到二叉树: 
>
>数组i的左节点:2*i+1
>
>数组i的右节点:2*i+2
>
>数组i的父节点:i-1/2
>
>heapify和heapinsert
>
>O(nlogn)



**排序总结**

|            | 时间复杂度 | 空间复杂度 | 稳定性 |
| ---------- | ---------- | ---------- | ------ |
| 选择       | O(n平方)   | O(1)       | No     |
| 冒泡       | O(n平方)   | O(1)       | Yes    |
| 插入       | O(n平方)   | O(1)       | Yes    |
| 归并       | O(nlogn)   | O(n)       | Yes    |
| 快排(随机) | O(nlogn)   | O(logn)    | No     |
| 堆排序     | O(nlogn)   | O(1)       | No     |

综合排序: 大范围快排,小范围插入(常数项极低)

Timsort: 合并排序+插入排序





#### 单链表

1.链表是否是回文(链表正反一样)

>笔试:放到栈里，出栈来比较 | 快慢指针(慢指针走一步/快指针走两步)
>
>面试: 快慢指针,指针走到中间，将后面逆序,在分别比较两个指针

2.将链表按某值划分成左边小，中间相等，右边大

>笔试: 所有节点放到数组，数组在parttion,在串起来
>
>面试: 需要六个变量,小于部分头，小于部分尾，等于部分头，等于部分尾，大于部分头，大于部分尾

3.复制含有随机指针节点的链表

>笔试: 使用哈希表(key为node,value为node')
>
>面试: 生成复制节点(复制节点在原节点的next) node1->node1'->node2->node2',最后分离老新的链表

4.链表相交问题

>有环无环问题？
>
>>笔试: 通哈希表,依次遍历并放到哈希表中
>>
>>面试: 快慢指针(快慢指针都在第一个节点，有环快慢指针一定会相遇，相遇后，慢指针停在原地，快指针移到开头，然后快慢同时走一步会在入环点相遇)
>
>**都无环**
>
>>长链表先走差值部分
>
>**一个有环一个无环**
>
>>不可能相交
>
>**都有环**
>
>>环相同或环不同但一定与相遇



#### 二叉树

递归与非递归实现二叉树的先序、中序、后序遍历

二叉树的递归序(每个节点都会回到三次)

都可以由递归序来(每次打印时机)

**先序遍历**

>每个子树都是(头左右)

**中序遍历**

>每个子树都是(左头右)

**后序遍历**

>每个子树都是(左右头) 	





